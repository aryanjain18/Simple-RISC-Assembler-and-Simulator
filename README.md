

# RISC Assembler and Simulator
### CSE112 - Computer Organisation - Course Project

## Introduction

This project is a RISC (Reduced Instruction Set Computing) assembler and simulator implemented in Python 3. The assembler component translates RISC instructions into their corresponding binary representation, while the simulator reverses this process by executing the binary instructions and maintaining the system's state.

## Features

### Assembler

The assembler takes human-readable RISC assembly code and converts it into machine-readable binary code. It supports a variety of RISC instructions and generates the corresponding binary output that can be executed by the simulator.

### Simulator

The simulator reads binary code generated by the assembler and executes the instructions, emulating the behavior of a RISC-based system. It keeps track of the system's state, including registers and memory, providing insights into the execution flow.

## Supported Instructions

The assembler and simulator support a basic set of RISC instructions, including but not limited to:

- Arithmetic instructions (add, subtract, multiply, divide)
- Logic instructions (AND, OR, XOR)
- Memory instructions (load, store)
- Control flow instructions (jump, branch)

Refer to the documentation or comments in the source code for the complete list of supported instructions.

## Acknowledgments

- This project was inspired by the principles of RISC architecture.
- Special thanks to [List of RISC architectures](https://en.wikipedia.org/wiki/List_of_RISC_architectures) for reference.

## TASK - Build an Assembler and a Simulator for the given ISA

We designed a robust splitter function that meticulously examines for errors, coupled with the systematic space splitting of each line. The subsequent utilization of the assemble_out function facilitates the conversion of assembly code into binary machine code. To enhance organization and efficiency, dictionaries were introduced for variables, labels, commands, and command lines.

Further, we classified the functions into distinct types (a, b, c, d, e, f) as prescribed in the procedural guidelines. Complementary routines were then implemented to meticulously convert the instructions of each type into machine code, ensuring precision and accuracy.

In order to enhance the utility of the system, we integrated file I/O functionalities, enabling seamless input extraction from a text file and the generation of the final output in a text file format. This meticulous approach ensures a professional and streamlined implementation of the entire process.

## Files

errors.py - all the error functions that need to be handled and debugged have been implemented case by case in this file accordingly.

Final_SimpleAssembler.py - contains the final code for compilation and conversion of all type of instructions.

params.py - contains all the parameters for opcodes and register codes in the format of dictionary.

input_file.txt - is the input

machine_code_output.txt - contains the generated machine code.
